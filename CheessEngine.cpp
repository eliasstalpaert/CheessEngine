//
// Created by eliass on 13/12/22.
//

#include "CheessEngine.hpp"
#include <tuple>
#include <memory>

CheessEngine::CheessEngine() : halfmove_counter{0}{

}


std::string CheessEngine::name() const {
    return "Cheess Engine";
}

std::string CheessEngine::version() const {
    return "1";
}

std::string CheessEngine::author() const {
    return "Elias Stalpaert";
}

void CheessEngine::newGame() {
  //Reset state of the engine
}

/*****************
 *
 * MOVE SEARCHING
 *
 * ******************/

PrincipalVariation CheessEngine::pv(const Board &board, const TimeInfo::Optional &timeInfo) {
    //Compute PV of given board
    auto negamax_pv = negamaxSearch(board, 5, -100000, 100000, 1);
    timeInfo.has_value();
    //Compute for each legal move the negamax value
    //If no legal moves, checkmate/stalemate
    return PrincipalVariation(std::move(std::get<0>(negamax_pv)), std::get<1>(negamax_pv));
}

std::tuple<PrincipalVariation::MoveVec ,int32_t> CheessEngine::negamaxSearch(const Board &board, unsigned int depth, int32_t alpha, int32_t beta, int turn) const {
    if(depth == 0) return std::make_tuple(PrincipalVariation::MoveVec(), evalPosition(board) * turn); //Return negamax score from current player's viewpoint

    //Generate moves, if no legal moves, check for stalemate/checkmate and assign score
    Board::MoveVec possible_moves = generateLegalMoves(board);

    //No legal moves, checkmate or stalemate
    if(possible_moves.empty()) {
        if(board.checkedPlayer()) return std::make_tuple(PrincipalVariation::MoveVec(),-100000); //checkmate
        else return std::make_tuple(PrincipalVariation::MoveVec(),0); //stalemate
    }

    //TODO: order moves
    //Initialize
    Move best_move;
    bool new_pv_move = false;
    PrincipalVariation::MoveVec best_pv;

    for(size_t move_ind = 0; move_ind < possible_moves.size(); move_ind++){
        //create copy of board
        Board copy_board(board);
        Move& current_move = possible_moves[move_ind];

        copy_board.makeMove(current_move);
        copy_board.setTurn(!board.turn());

        auto next_move = negamaxSearch(copy_board, depth - 1, -beta, -alpha, -turn);
        int32_t new_score = -1 * std::get<1>(next_move);

        if(new_score > alpha) {
            alpha = new_score;
            new_pv_move = true;
            best_move = current_move; //Remember potential best move belonging to new_score
            best_pv = PrincipalVariation::MoveVec(std::get<0>(next_move)); //Remember pv that led to the score
        }

        if(alpha >= beta) break; //other moves shouldn't be considered (fail-hard beta cutoff)
    }
    if(new_pv_move) best_pv.push_back(best_move);
    return std::make_tuple(best_pv, alpha);
}

/**************
 *
 * MOVE ORDERING
 *
 * **************/

/*************
 *
 * LEGAL MOVE GENERATION (uses isSquareAttacked and MakeMove)
 *
 * ****************/

//Results in mate or takes king not allowed

Board::MoveVec CheessEngine::generateLegalMoves(const Board &board) const {
    Board::MoveVec moves;
    board.pseudoLegalMoves(moves);

    for(size_t i = 0; i < moves.size(); i++) {
        Board copy_board = board;
        copy_board.makeMove(moves[i]);
        if(bool checked = copy_board.isPlayerChecked()) {
            checked = copy_board.isPlayerChecked();
            if(checked) moves.erase(moves.begin() + i);
        }
    }
    //Check pinned pieces and eliminate them from the moves (pinned status should be removed after resolving checkmate)
    //When checkmate, detect attacking (xray attacks) of attacking piece (for potential blockers)
    //Then check attacked squares by other pieces to make sure king doesn't move into attacking territory
    return moves;
}
//If current player moves king, check for checkmate/stalemate in moves generated by opponent (defines the attacked square)

//If no valid moves (every move leaves king in check, meaning no legal moves anymore)
//and the opponent can take the king (current player was already checked), opponent wins otherwise stalemate

/****************
 *
 * BOARD EVALUATION
 *
 * ******************/

//Static scores
//Fifty move draw using current value of halfmove counter
//Threefold repetition check
//TODO: Forcing a draw with special rules

int32_t CheessEngine::evalPosition(const Board &board) const {
    //Indien opponent checked is, wilt dit niet zeggen dat het checkmate of stalemate is, moet nog gecheckt worden
    board.turn();
    return 0;
}

/**************
 *
 * TRANSPOSITION TABLES
 *
 * *****************/

std::optional<HashInfo> CheessEngine::hashInfo() const {
    //Only relevant if transposition tables are used
    return Engine::hashInfo();
}

void CheessEngine::setHashSize(std::size_t size) {
    //Only relevant if transposition tables are used
    Engine::setHashSize(size);
}

